<html>
<style>

  .line {
    stroke-width: 2;
    stroke-miterlimit: 1;
    stroke-linecap: round;
    fill: none;
  }

  .axis-title {
    font-family: sans-serif;
    font-size: 16px;
    font-weight: bold;
    text-anchor: middle;
    fill: black;
  }

  .grid line {
    stroke: lightgray;
  }

  .majorFireInfoText {
    font-family: sans-serif;
    font-size: 14px;
    fill: black;
  }

</style>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-shape.v1.min.js"></script>
<head>
  <title>California Wildfiires 2013 - 2019</title>
</head>
<body>
  <h1 id="yearText" style="text-align:leftr"></h1>
<div id="filters">
  <button id="nextButton">Next</button>
</div>  
<div id="map"></div>
<div id="chart"></div>
<script>

var width = 640;
var height = 640;
var margin = 100;
var topMargin = 40;
const transitionTime = 5000;   // The ammount of time the trasntions should last
var currentYear = 2013;
var colors =  d3.scaleOrdinal(d3.schemeCategory10); // The color scale

d3.select("#yearText").text(currentYear + " California Wildfires ");

// Create svg for map
var map = d3.select("#map")
  .append("svg")
    .attr("width", width + 2*margin)
    .attr("height", height + margin);

var cal = d3.json("https://raw.githubusercontent.com/GregHarrison/CS498-Narrative-Vis/master/ca.json");
var cal_fires = d3.csv("https://raw.githubusercontent.com/GregHarrison/CS498-Narrative-Vis/master/Cal_Fires.csv");

Promise.all([cal, cal_fires]).then(function(values) {
  
  var parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%SZ");
  var fireDateParse = d3.timeFormat("%b %d, %Y");

  // Parse data
  values[1].forEach(function(d) {
    d.AcresBurned = +d.AcresBurned;
    d.RunSumAcresBurned = +d.RunSumAcresBurned;
    d.Started = parseTime(d.Started);
    d.Extinguished = parseTime(d.Extinguished);
  })

  // create list of years
  var years = d3.map(values[1], function(d) { return d.ArchiveYear; }).keys()

  var projection = d3.geoConicEqualArea().parallels([34, 40.5]).rotate([120,0]).fitSize([width,height], values[0]);
  
  var path = d3.geoPath().projection(projection);

  map.append("g")
    .attr("id", "caliMap")
    .attr("transform", "translate("+margin+","+topMargin+")")
    .append("path")
      .attr("d", path(values[0]))
      .attr("fill", "#e5e5e5")
      .attr("stroke", "black")
      .attr("stroke-width", ".5px");
  
  // Create a scale to translate a year into the transition time
  var transitionScale = d3.scaleLinear()
    .domain([0,365])
    .range([0,transitionTime]);

  /** Function assigns a position for annotations based on where fire occured.
      @param Longitude  The longitude position of the fire.
      @param Latitude   The lotitude position of the fire.
      @param annoWidth  The width of the annotation.
      @return   Function returns an array containing, in SVG coordinates, the x-coordinate
        of the annotation, the y-coordinate of the annotation, the x-coordinate of where
        the line pointing to the annotation text will end, the x-coordinate of where
        the line pointing to the annotation text will end, and the appropriate text
        allignment (left or right) of the annotation text.*/ 
  function annoPosition(Longitude, Latitude, annoWidth) {
    var xOffset = 160;  // X offset for positioning annotations
    var yOffset = 30;   // Y offset for positioning annotations
    var annoLong = -122.5;
    var annoLat = 36.5;

    // If fire in far north
    if (Latitude > 40.5) {
      return [projection([Longitude,Latitude])[0] + xOffset + 30, projection([Longitude,Latitude])[1] - yOffset - 20, 
        projection([Longitude,Latitude])[0] + xOffset + 25, projection([Longitude,Latitude])[1] - yOffset - 10, "left"]
    } 
    // If fire in Southeast
    else if (Latitude <= annoLat && Longitude > annoLong) {
      return [projection([Longitude,Latitude])[0] - xOffset - 150, projection([Longitude,Latitude])[1] + yOffset,
        projection([Longitude,Latitude])[0] - xOffset - 150 + (annoWidth + 3), 
        projection([Longitude,Latitude])[1] + yOffset + 8, "right"]
    } 
    // If fire in Northwest
    else if (Latitude > annoLat && Longitude <= annoLong) {
      return [projection([Longitude,Latitude])[0] - (xOffset + 100), projection([Longitude,Latitude])[1] + 3*yOffset,
        projection([Longitude,Latitude])[0] - (xOffset + 100) + (annoWidth + 3), 
        projection([Longitude,Latitude])[1] + 3*yOffset + 8, "right"]
    } 
    // If fire in Northeast
    else {
      return [projection([Longitude,Latitude])[0] + xOffset, projection([Longitude,Latitude])[1] - yOffset, 
        projection([Longitude,Latitude])[0] + xOffset - 5, projection([Longitude,Latitude])[1] - yOffset + 10, "left"]
    }
  }

  /** Function will display fires on the map as circles with size reltaive to the 
      amount of acres burned. 
      @param year  The year to display data for. */
  function drawCirclesAnimated(year) {
    
    var yearStartDate = new Date(year,00,00,00,00,00);
    var yearEndDate = new Date(year,11,31,23,59,59);
    var annoWidth = 250
    var annoHeight = 78
    

    // Filter for only major fires
    var majorFires = values[1].filter(d => d.AcresBurned > 70000).filter(d => d.ArchiveYear==year);
    
    // Create a conversion to set the radious of circle to be proportional to the acres burned
    var acres2radious = d3.scaleSqrt()
      .domain([0, d3.max(values[1], function(d) { return d.AcresBurned; } )])
      .range([1,35]);
  
    // Create circles at latitude and longitude location of each fire.
    // Circles spawn when fire started and last for time interval of fire
    map.append("g")
      .attr("id", "fireCircles")
      .attr("transform", "translate("+margin+","+topMargin+")")
      .selectAll("circle")
      .data(values[1].filter(function(d) { return d.ArchiveYear==year; }))
      .enter()
      .append("circle")
        .attr("cx", function(d) { return projection([d.Longitude,d.Latitude])[0]; })
        .attr("cy", function(d) { return projection([d.Longitude,d.Latitude])[1]; })
        .attr("fill", colors(year % 7))
        .transition()
          .delay(function(d) { return transitionScale(d3.timeDay.count(yearStartDate, d.Started)); })
          .duration(function(d) { return transitionScale(d3.timeDay.count(d.Started, d.Extinguished)); })
          .attr("r", function(d) { return acres2radious(d.AcresBurned); })
          .attr("opacity", 1)
        .transition()
          .duration(0)
          .attr("opacity", .35);

    // Filter for only major fires
    var majorFires = values[1].filter(d => d.AcresBurned > 77000).filter(d => d.ArchiveYear==year);
    
    // Create a foreign object with embedded html to display detail of major fires
    map.append("g")
      .attr("id", "majorFireInfoText")
      .attr("class", "majorFireInfoText")
      .attr("transform", "translate("+margin+","+topMargin+")")
      .selectAll("foreignObject")
      .data(majorFires)
      .enter()
      .append("foreignObject")
        .style("text-align", d =>annoPosition(d.Longitude, d.Latitude, annoWidth)[4])
        .attr("x", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[0])
        .attr("y", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[1])
        .attr("width", annoWidth)
        .attr("height", annoHeight)
        .html(d => "<b>" + d.Name + "</b>" 
              + "<br>" + fireDateParse(d.Started) + " - " + fireDateParse(d.Extinguished)
              + "<br>Acres Burned: " + d.AcresBurned + "<br>Structures Destroyed: " + d.StructuresDestroyed)
        .attr("opacity", 0)
        .transition()
          .delay(d => transitionScale(d3.timeDay.count(yearStartDate, d.Started)))
          .duration(0)
          .attr("opacity", 1);

    // Create lines to point from annotation to fire center
    map.append("g")
      .attr("id", "annotationLine")
      .attr("transform", "translate("+margin+","+topMargin+")")
      .selectAll("line")
      .data(majorFires)
      .enter()
      .append("line")
        .attr("x1", d => projection([d.Longitude,d.Latitude])[0])
        .attr("y1", d => projection([d.Longitude,d.Latitude])[1])
        .attr("x2", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[2])
        .attr("y2", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[3])
        .attr("stroke", "black")
        .attr("stroke-width", "1px")
        .attr("opacity", 0)
        .transition()
          .delay(d => transitionScale(d3.timeDay.count(yearStartDate, d.Started)))
          .duration(0)
          .attr("opacity", 1);
  }

  /** Function will display fires on the map as circles with size reltaive to the 
      amount of acres burned. 
      @param year  The year to display data for. */
  function drawCircles(year) {
    
    var yearStartDate = new Date(year,00,00,00,00,00);
    var yearEndDate = new Date(year,11,31,23,59,59);
    var annoWidth = 250
    var annoHeight = 78

    // Filter for only major fires
    var majorFires = values[1].filter(d => d.AcresBurned > 77000).filter(d => d.ArchiveYear==year);

    // Create a conversion to set the radious of circle to be proportional to the acres burned
    var acres2radious = d3.scaleSqrt()
      .domain([0, d3.max(values[1], function(d) { return d.AcresBurned; } )])
      .range([1,35]);
  
    // Create circles at latitude and longitude location of each fire.
    // Circles spawn when fire started and last for time interval of fire.
    map.append("g")
      .attr("id", "fireCircles")
      .attr("transform", "translate("+margin+","+topMargin+")")
      .selectAll("circle")
      .data(values[1].filter(function(d) { return d.ArchiveYear==year; }))
      .enter()
      .append("circle")
        .attr("cx", function(d) { return projection([d.Longitude,d.Latitude])[0]; })
        .attr("cy", function(d) { return projection([d.Longitude,d.Latitude])[1]; })
        .attr("fill", colors(year % 7))
        .attr("r", function(d) { return acres2radious(d.AcresBurned); })
        .attr("opacity", 0.7);

    // Create a foreign object with embedded html to display detail of major fires
    map.append("g")
      .attr("id", "majorFireInfoText")
      .attr("class", "majorFireInfoText")
      .attr("transform", "translate("+margin+","+topMargin+")")
      .selectAll("foreignObject")
      .data(majorFires)
      .enter()
      .append("foreignObject")
        .style("text-align", d =>annoPosition(d.Longitude, d.Latitude, annoWidth)[4])
        .attr("x", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[0])
        .attr("y", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[1])
        .attr("width", annoWidth)
        .attr("height", annoHeight)
        .html(d => "<b>" + d.Name + "</b>" 
              + "<br>" + fireDateParse(d.Started) + " - " + fireDateParse(d.Extinguished)
              + "<br>Acres Burned: " + d.AcresBurned + "<br>Structures Destroyed: " + d.StructuresDestroyed)
    
    // Create lines to point from annotation to fire center
    map.append("g")
      .attr("id", "annotationLine")
      .attr("transform", "translate("+margin+","+topMargin+")")
      .selectAll("line")
      .data(majorFires)
      .enter()
      .append("line")
        .attr("x1", d => projection([d.Longitude,d.Latitude])[0])
        .attr("y1", d => projection([d.Longitude,d.Latitude])[1])
        .attr("x2", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[2])
        .attr("y2", d => annoPosition(d.Longitude, d.Latitude, annoWidth)[3])
        .attr("stroke", "black")
        .attr("stroke-width", "1px")
  }

  // Initialize map with 2013 data
  drawCirclesAnimated(currentYear);

  // Scale x-axis. This is a constant in order to keep that axis from changing
  // while the data changes years.
  var xAxis = d3.scaleTime()
    .domain([new Date(2013,00,01,00,00,00), new Date(2013,11,31,23,59,59)])
    .range([0, width]);
 
  // Scale y-axis
  var y = d3.scaleLinear()
    .domain([0, d3.max(values[1], function(d) { return d.RunSumAcresBurned; })])
    .range([height/2, 0])
    .nice();
  
  var chart = d3.select("#chart")
    .append("svg")
      .attr("width", width + 2*margin)
      .attr("height", height/2 + 2*margin)
      .append("g")
        .attr("id", "lineChart")
        .attr("transform","translate("+(margin-20)+", 30)")

  // Add y axis
  chart.append("g")
    .attr("id", "yAxis")
    .attr("class", "grid")
    .attr("transform", "translate("+margin+", 0)")
    .call(d3.axisLeft(y).tickSize(-width).tickFormat(d3.format(".2s")))
    .append("text")
      .attr("class", "axis-title")
      .attr("y", 0 - 40)
      .attr("x", 0 - (height/4))
      .attr("transform", "rotate(-90)")
      .text("Cumulative Sum of Acres Burned");
  
  // Add x axis
  chart.append("g")
      .attr("id", "xAxis")
      .attr("transform", "translate("+margin+", "+height/2+")")
      .call(d3.axisBottom(xAxis)
        .ticks(12)
        .tickFormat(d3.timeFormat("%b")));

  // Create an element for the line
  chart.append("g")
      .attr("id", "line")
      .attr("transform", "translate("+margin+", 0)");

  /** Function will draw an animated line chart showing the cumulative amount of 
      acres burned over a given year. 
      @param year  The year to display data for. */
  function drawChart(year) {
    
    var yearStartDate = new Date(year,00,01,00,00,00);
    var yearEndDate = new Date(year,11,31,23,59,59);

    // Scale for the x-coordinates
    var xCoords = d3.scaleTime()
      .domain([yearStartDate, yearEndDate])
      .range([0, width]);

    var line = d3.line()
      .x(function(d) { return xCoords(d.Started); })
      .y(function(d) { return y(d.RunSumAcresBurned); })
      .curve(d3.curveBundle.beta(.7));

    var path = d3.select("#line")
      .append("path")
      .datum(values[1].filter(function(d) { return d.ArchiveYear==year; }))
      .attr("class", "line")
      .attr("id", "y" + year)
      .attr("d", line)
      .attr("stroke", colors(year % 7));

    var totalLength = path.node().getTotalLength();

    path
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
        .duration(transitionTime)
        .attr("stroke-dashoffset", 0);
  }
  
  // Initialize chart with 2013 data
  drawChart(currentYear);

  /** Update the page for the appropriate year.
      @param year  The year to display data for. */
  function updateDisplayAnimated(year) {

    // Remove all circles from the map
    d3.select("#fireCircles").remove();
    
    // Remove all annotations from map
    d3.select("#majorFireInfoText").remove();
    d3.select("#annotationLine").remove();
    
    // lower opacity of lines outside of current year
    d3.select("#line").selectAll("*").attr("opacity", 0.3);
    
    // Update header with current year
    d3.select("#yearText").text(year + " California Wildfires ");

    // Draw circles for chosen year
    drawCirclesAnimated(year);

    // Draw line chart for chosen year
    drawChart(year);
  }

  /** Update the page for the appropriate year.
      @param year  The year to display data for. */
  function updateDisplay(year) {

    // Remove all circles from the map
    d3.select("#fireCircles").remove();
    
    // Remove all annotations from map
    d3.select("#majorFireInfoText").remove();
    d3.select("#annotationLine").remove();
    
    // lower opacity of lines outside of current year
    d3.select("#line").selectAll("*").attr("opacity", 0.3);
    
    // Update header with current year
    d3.select("#yearText").text(year + " California Wildfires ");

    // Draw circles for chosen year
    drawCircles(year);

    // Draw line chart for chosen year
    d3.select("#y" + year).attr("opacity", 1);
  }

  /** Function replaces the next button with a selector so that the viewer
      can go back and look at data from a specific year. */
  function changeButtons() {
    d3.select("#nextButton").remove();
      
    d3.select("#filters").append("select").attr("id", "yearButton")
      .selectAll("myOptions")
        .data(years)
      .enter()
        .append("option")
          .text(d => d)
          .attr("value", d => d)

    d3.select("#yearButton")
      .on("change", function(d) {
        var selection = d3.select(this).property("value");
        updateDisplay(selection);
        currentYear = selection;
      });
  }

  d3.select("#nextButton")
    .on("click", function(d) {
      var nextYear = currentYear + 1;
      updateDisplayAnimated(nextYear);
      currentYear = nextYear;
      if (currentYear == 2019) {
        changeButtons();
      }
    });
});

</script>
</body>
</html>